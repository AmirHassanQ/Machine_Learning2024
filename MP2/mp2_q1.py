# -*- coding: utf-8 -*-
"""MP2_Q1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zlIdAUwtZ_xCCYRcMcBMlq5CRMoEiH2C

# part1 draw triangle

import libraries
"""

import numpy as np
import matplotlib.pyplot as plt

"""define Neuron"""

class McCulloch_Pitts():
  def __init__(self,weightes,thr):
    self.weightes = weightes
    self.thr = thr
  def model(self,x):
    if self.weightes@x >= self.thr :
      return 1
    else:
      return 0

def Triangle(x,y):
  neur1 = McCulloch_Pitts([-2 , -1] ,  6 )
  neur2 = McCulloch_Pitts([+2 , -1] , -2 )
  neur3 = McCulloch_Pitts([ 0 , +1] ,  0 )
  neur4 = McCulloch_Pitts([1 , 1 , 1] , 3 )

  z1 = neur1.model(np.array([x,y]))
  z2 = neur2.model(np.array([x,y]))
  z3 = neur3.model(np.array([x,y]))
  z4 = neur4.model(np.array([z1 , z2 , z3]))


  return list([z4])
  #return(neur1)

"""plot"""

# define vertices
tri_vertices = [(2, 2), (3, 0), (1, 0)]

for x, y in tri_vertices :
  if x==2:
    vertice = 'A'
  elif x==3:
    vertice = 'B'
  elif x==1:
    vertice = 'C'
  plt.annotate(vertice+f'({x}, {y})', (x, y), textcoords="offset points", xytext=(-19,1), ha='center', fontsize = 10)

x_1 = [2,3]
y_1 = [2,0]
x_2 = [1,2]
y_2 = [0,2]
x_3 = [1,3]
y_3 = [0,0]
# Plotting lines with legends
plt.plot(x_1 , y_1 , color='blue', linestyle='solid')
plt.plot(x_2 , y_2 , color='blue', linestyle='solid')
plt.plot(x_3 , y_3 , color='blue', linestyle='solid', label='Triangle')


# Extracting x and y coordinates
triangle_x = [v[0] for v in tri_vertices]
triangle_y = [v[1] for v in tri_vertices]

# Adding the first vertex at the end to close the polygon
triangle_x.append(tri_vertices[0][0])
triangle_y.append(tri_vertices[0][1])

# Filling the triangle with hatching
plt.fill(triangle_x, triangle_y, facecolor='pink', edgecolor='green',  fill=True, hatch='/', linewidth=0.1, alpha=0.4,label = 'Area Inside Triangle')


# axis limits
plt.xlim(0, 4)
plt.ylim(-1, 3)

# Position the legends at the top and right
plt.legend(loc='upper right', bbox_to_anchor=(1.5, 1.02))

plt.title('Graph with Lines and Hatched Area(Triangle)')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.grid(True)
plt.savefig('zone of triangle.png')

plt.show()

"""#part2 classify red and green points

importing libraries
"""

import numpy as np
import matplotlib.pyplot as plt

"""define Neuron"""

#define muculloch pitts
class McCulloch_Pitts_neuron():
  def __init__(self, weights , threshold):
    self.weights = weights
    self.threshold = threshold

  def model(self, X ):
    if ((self.weights @ X)  + self.threshold) >= 0 :
      return 1
    else :
      return 0

def Triangle(x,y):
  neur1 = McCulloch_Pitts_neuron([-2 , -1] ,  6 )
  neur2 = McCulloch_Pitts_neuron([+2 , -1] , -2 )
  neur3 = McCulloch_Pitts_neuron([ 0 , +1] ,  0 )
  neur4 = McCulloch_Pitts_neuron([1 , 1 , 1] , -3 )

  zone1 = neur1.model(np.array([x,y]))
  zone2 = neur2.model(np.array([x,y]))
  zone3 = neur3.model(np.array([x,y]))
  zone4 = neur4.model(np.array([zone1 , zone2 , zone3]))


  return list([zone4])
  #return(neur1)

"""Generate random data points"""

num_points = 2000
x_values = np.random.uniform( 0 , 4 , num_points )
y_values = np.random.uniform( -1 , 3 , num_points )

red_point = [] # outside zone
green_point = [] #  inside zone

for i in range(num_points):
  flag = Triangle(x_values[i] , y_values[i])
  if flag == [0] :
    red_point.append((x_values[i] , y_values[i]))
  else:
    green_point.append((x_values[i] , y_values[i]))


# Separate x and y values for red and green points
red_x, red_y = zip(*red_point)
green_x, green_y = zip(*green_point)

# Plotting
plt.figure(figsize=(8, 6))
plt.scatter(red_x, red_y, color='red', label='z4 = 0')
plt.scatter(green_x, green_y, color='green', label='z4 = 1')
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('McCulloch-Pitts Neuron Outputs')
plt.grid(True)

# define vertices
tri_vertices = [(2, 2), (3, 0), (1, 0)]

for x, y in tri_vertices :
  if x==2:
    vertice = 'A'
  elif x==3:
    vertice = 'B'
  elif x==1:
    vertice = 'C'
  plt.annotate(vertice+f'({x}, {y})', (x, y), textcoords="offset points", xytext=(-19,1), ha='center', fontsize = 12)

x_1 = [2,3]
y_1 = [2,0]
x_2 = [1,2]
y_2 = [0,2]
x_3 = [1,3]
y_3 = [0,0]
# Plotting lines with legends
plt.plot(x_1 , y_1 , color='blue', linestyle='solid')
plt.plot(x_2 , y_2 , color='blue', linestyle='solid')
plt.plot(x_3 , y_3 , color='blue', linestyle='solid', label='Triangle')


# Extracting x and y coordinates
triangle_x = [v[0] for v in tri_vertices]
triangle_y = [v[1] for v in tri_vertices]

# Adding the first vertex at the end to close the polygon
triangle_x.append(tri_vertices[0][0])
triangle_y.append(tri_vertices[0][1])

# Filling the triangle with hatching
plt.fill(triangle_x, triangle_y, facecolor='pink', edgecolor='green',  fill=True, hatch='/', linewidth=0.1, alpha=0.4,label = 'Area Inside Triangle')


# axis limits
plt.xlim(0, 4)
plt.ylim(-1, 3)

# Position the legends at the top and right
plt.legend(loc='upper right', bbox_to_anchor=(1.5, 1.02))

plt.title('McCulloch-Pitts Neuron Outputs')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.grid(True)

plt.savefig('zone of triangle with random points.png', bbox_inches='tight')

plt.show()

"""Generate random data points"""

num_points = 2000
x_values = np.random.uniform(0, 4, num_points)  # Updated x-axis limits
y_values = np.random.uniform(-1,3, num_points)  # Updated y-axis limits

class McCulloch_Pitts_neuron:
    def __init__(self, weights, threshold):
        self.weights = np.array(weights)
        self.threshold = threshold

    def model(self, X):
        X = np.array(X)
        linear_output = self.weights @ X + self.threshold
        return self.activation(linear_output)

    def activation(self, linear_output):
        # Default to the original threshold logic without an activation function
        return 1 if linear_output >= 0 else 0

    def set_activation_function(self, activation_func):
        self.activation = activation_func

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def relu(x):
    return np.maximum(0, x)

def Triangle(x,y):
  neur1 = McCulloch_Pitts_neuron([-2 , -1] ,  6 )
  # Set activation functions
#  neur1.set_activation_function(sigmoid)
  neur2 = McCulloch_Pitts_neuron([+2 , -1] , -2 )
#  neur2.set_activation_function(sigmoid)
  neur3 = McCulloch_Pitts_neuron([ 0 , +1] ,  0 )

  neur4 = McCulloch_Pitts_neuron([1 , 1 , 1] , -3 )
  neur4.set_activation_function(sigmoid)

  zone1 = neur1.model(np.array([x,y]))
  zone2 = neur2.model(np.array([x,y]))
  zone3 = neur3.model(np.array([x,y]))
  zone4 = neur4.model(np.array([zone1 , zone2 , zone3]))


  return list([zone4])

red_point = [] # outside zone
green_point = [] #  inside zone

for i in range(num_points):
  flag = Triangle(x_values[i] , y_values[i])
  if flag != [0.5] :
    red_point.append((x_values[i] , y_values[i]))
  else:
    green_point.append((x_values[i] , y_values[i]))


# Separate x and y values for red and green points
red_x, red_y = zip(*red_point)
green_x, green_y = zip(*green_point)

# Plotting
plt.figure(figsize=(8, 6))
plt.scatter(red_x, red_y, color='red', label='z4 = 0')
plt.scatter(green_x, green_y, color='green', label='z4 = 1')
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('McCulloch-Pitts Neuron Outputs')
plt.grid(True)

# Annotating the vertices
triangle_vertices = [(2, 2), (3, 0), (1, 0)]
for x, y in tri_vertices :
  if x==2:
    vertice = 'A'
  elif x==3:
    vertice = 'B'
  elif x==1:
    vertice = 'C'
  plt.annotate(vertice+f'({x}, {y})', (x, y), textcoords="offset points", xytext=(-19,1), ha='center', fontsize = 12)

x_l1 = [2,3]
y_l1 = [2,0]
x_l2 = [1,2]
y_l2 = [0,2]
x_l3 = [1,3]
y_l3 = [0,0]
# Plotting lines with legends
plt.plot(x_l1 , y_l1 , color='blue', linestyle='solid')
plt.plot(x_l2 , y_l2 , color='blue', linestyle='solid')
plt.plot(x_l3 , y_l3 , color='blue', linestyle='solid', label='Triangle')
# ValueError: '_' is not a valid value for ls; supported values are '-', '--', '-.', ':', 'None', ' ', '', 'solid', 'dashed', 'dashdot', 'dotted'

# Extracting x and y coordinates
triangle_x = [v[0] for v in triangle_vertices]
triangle_y = [v[1] for v in triangle_vertices]

# Adding the first vertex at the end to close the polygon
triangle_x.append(triangle_vertices[0][0])
triangle_y.append(triangle_vertices[0][1])

# Filling the triangle with hatching
plt.fill(triangle_x, triangle_y, facecolor='pink', edgecolor='green',  fill=True, hatch='/', linewidth=0.1, alpha=0.4)


# Set axis limits
plt.xlim(0, 4)
plt.ylim(-1, 3)

# Position the legends at the top and right
plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.02))

# Save plot as PDF
plt.savefig('c.png', bbox_inches='tight')

plt.show()

def Triangle(x,y):
  neur1 = McCulloch_Pitts_neuron([-2 , -1] ,  6 )
  # Set activation functions
#  neur1.set_activation_function(sigmoid)
  neur2 = McCulloch_Pitts_neuron([+2 , -1] , -2 )
#  neur2.set_activation_function(sigmoid)
  neur3 = McCulloch_Pitts_neuron([ 0 , +1] ,  0 )

  neur4 = McCulloch_Pitts_neuron([1 , 1 , 1] , -3 )
  neur4.set_activation_function(relu)

  zone1 = neur1.model(np.array([x,y]))
  zone2 = neur2.model(np.array([x,y]))
  zone3 = neur3.model(np.array([x,y]))
  zone4 = neur4.model(np.array([zone1 , zone2 , zone3]))


  return list([zone4])

red_point = [] # outside zone
green_point = [] #  inside zone

for i in range(num_points):
  flag = Triangle(x_values[i] , y_values[i])
  if flag != [0.5] :
    red_point.append((x_values[i] , y_values[i]))
  else:
    green_point.append((x_values[i] , y_values[i]))


# Separate x and y values for red and green points
red_x, red_y = zip(*red_point)
green_x, green_y = zip(*green_point)

# Plotting
plt.figure(figsize=(8, 6))
plt.scatter(red_x, red_y, color='red', label='z4 = 0')
plt.scatter(green_x, green_y, color='green', label='z4 = 1')
plt.xlabel('x1')
plt.ylabel('x2')
plt.title('McCulloch-Pitts Neuron Outputs')
plt.grid(True)

# Annotating the vertices
triangle_vertices = [(2, 2), (3, 0), (1, 0)]
for x, y in tri_vertices :
  if x==2:
    vertice = 'A'
  elif x==3:
    vertice = 'B'
  elif x==1:
    vertice = 'C'
  plt.annotate(vertice+f'({x}, {y})', (x, y), textcoords="offset points", xytext=(-19,1), ha='center', fontsize = 12)

x_l1 = [2,3]
y_l1 = [2,0]
x_l2 = [1,2]
y_l2 = [0,2]
x_l3 = [1,3]
y_l3 = [0,0]
# Plotting lines with legends
plt.plot(x_l1 , y_l1 , color='blue', linestyle='solid')
plt.plot(x_l2 , y_l2 , color='blue', linestyle='solid')
plt.plot(x_l3 , y_l3 , color='blue', linestyle='solid', label='Triangle')
# ValueError: '_' is not a valid value for ls; supported values are '-', '--', '-.', ':', 'None', ' ', '', 'solid', 'dashed', 'dashdot', 'dotted'

# Extracting x and y coordinates
triangle_x = [v[0] for v in triangle_vertices]
triangle_y = [v[1] for v in triangle_vertices]

# Adding the first vertex at the end to close the polygon
triangle_x.append(triangle_vertices[0][0])
triangle_y.append(triangle_vertices[0][1])

# Filling the triangle with hatching
plt.fill(triangle_x, triangle_y, facecolor='pink', edgecolor='green',  fill=True, hatch='/', linewidth=0.1, alpha=0.4)


# Set axis limits
plt.xlim(0, 4)
plt.ylim(-1, 3)

# Position the legends at the top and right
plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.02))

# Save plot as PDF
plt.savefig('c.png', bbox_inches='tight')

plt.show()